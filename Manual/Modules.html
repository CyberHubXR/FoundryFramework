<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Modules in Foundry | Foundry Core </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Modules in Foundry | Foundry Core ">
      
      
      <link rel="icon" href="../Media/foundry_icon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/CyberHubXR/FoundryFramework/blob/main/Documentation/Manual/Modules.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../Media/foundry_icon.png" alt="Foundry Core">
            Foundry Core
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="modules-in-foundry">Modules in Foundry</h1>

<p>For foundry to be a modular system, we developed a services based framework that allows both core and packages to define services that can be swapped and used by other packages. This allows us to have a single API for things like networking, and allows us to swap out the implementation of that API depending on the package you have installed. It also provides a way for packages to provide services that other packages can use.</p>
<h2 id="how-it-works">How it works</h2>
<p>Foundry is built on the idea of modules, which while technically independent from Unity packages, there's usually one foundry module per Unity package.</p>
<p>Each module provides a couple of things that are automatically read from it. A name, source package, and a list of services it both provides and uses.</p>
<p>Once the config manager has scanned all of our packages for what services they use and provide it'll create a few scriptable assets in the <code>Assets/Foundry</code> folder that store which modules should provide which services, as well as a list of all the modules that are installed and should be loaded.</p>
<p>Then when an app is running you can grab an interface by calling <code>FoundryApp.GetService&lt;T&gt;()</code> where T is the interface you want to grab. What it returns is based on which module you selected to provide that service in the config manager.</p>
<pre><code class="lang-mermaid">flowchart TD
    A[FoundryApp class] -- &quot;Grab Interfaces from app&quot; --&gt; B[Game Code]
    C[ServiceInterface]
    D[Package 1 Implementation] --&gt; C
    E[Package 2 Implementation] --&gt; C
    C--&gt;A
</code></pre>
<h1 id="creating-a-module">Creating a Module</h1>
<p>Let's say you want to create a module that provides a service that other packages can use. First step is creating a new Unity package. We provide a <a href="https://github.com/FoundryXR/FoundryUnityPackageTemplate">GitHub template</a> for this, or you can create one from scratch using the docs from Unity:</p>
<div class="embeddedvideo"><iframe src="https://www.youtube-nocookie.com/embed/mgsLb3TKljk" frameborder="0" allowfullscreen="true"></iframe></div>
<p>After this we'll need to create two things for our module to function:</p>
<ol>
<li><a href="#module-config">Module Config</a></li>
<li><a href="#module-definition">Module Definition</a></li>
</ol>
<h2 id="module-config">Module Config</h2>
<p>The module config is a scriptable object that inherits from <code>Foundry.FoundryModuleConfig</code>. This is where you can store easily accessible settings for your module that will show up directly in the config manager, and it is also where foundry will store enabled services for your module behind the scenes.</p>
<p>Here's Foundry Core's module config as an example:</p>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Contains all settings to do with the foundry core package, not to be confused with the foundry app config, which stores settings about the application as a whole.
/// &lt;/summary&gt;
public class FoundryCoreConfig : FoundryModuleConfig
{
    // We don't have any settings here, but if we did they would be serialized and show up in the config manager.
    // For example if we had a setting called &quot;Enable Debug Logging&quot; we could do this:
    // public bool enableDebugLogging = false;
    // And it would show up in the config manager as a toggleable setting.

#if UNITY_EDITOR
    // This is a helper function that I like defining for singleton scriptable objects, not required but suggested
    public static FoundryCoreConfig GetAsset()
    {
        // If you use this function remember to the asset name in the path so that you're not overwriting other assets.

        var asset = UnityEditor.AssetDatabase.LoadAssetAtPath&lt;FoundryCoreConfig&gt;(
            &quot;Assets/Foundry/Settings/FoundryCoreConfig.asset&quot;);  
        if (asset == null)
        {
            asset = CreateInstance&lt;FoundryCoreConfig&gt;();
            Directory.CreateDirectory(&quot;Assets/Foundry/Settings&quot;);
            UnityEditor.AssetDatabase.CreateAsset(asset, &quot;Assets/Foundry/Settings/FoundryCoreConfig.asset&quot;);
        }
        return asset;
    }
#endif

    // This is the important part, this is where we give foundry constructors for all the services that we provide. 
    // The reason we provide callbacks instead of directly calling new, is so that behind the scenes foundry can
    // pick and choose which implementation of a service to use, depending on the current config.
    // So if there was a third party package installed that provided a different implementation of ISceneNavigator,
    // the callback here for it would not be called, and the third party implementation would be used instead.
    // But all the other services would still be provided by this module, if they're still enabled.
    public override void RegisterServices(Dictionary&lt;Type, ServiceConstructor&gt; constructors)
    {
        constructors.Add(typeof(ISceneNavigator), () =&gt; new SceneNavigator());
        constructors.Add(typeof(IPlayerRigManager), () =&gt; new PlayerRigManagerService());
        constructors.Add(typeof(IFoundryCameraManager), () =&gt; new FoundryCameraManager());
    }
}
</code></pre>
<p>Now in your module code, if you have settings defined in here that you want to access you can do so by calling <code>FoundryApp.GetConfig&lt;T&gt;()</code> where T is the type of your module config. This will return a reference to the config asset that you can then access your settings from.</p>
<h2 id="module-definition">Module Definition</h2>
<p>The module definition is simply a class that implements <code>Foundry.Core.Editor.IModuleDefinition</code>. This class is responsible for telling Foundry what services your module provides and uses.</p>
<p>Make sure you mark this code as editor only, as it's only used by the config manager. And references will break if you try to use it in game code.</p>
<p>Here's how we define the module for Foundry Core (Yes, even foundry core itself is a module!):</p>
<pre><code class="lang-cs">public class FoundryCoreModuleDefinition: IModuleDefinition
{
    public string ModuleName()
    {
        return &quot;Foundry Core&quot;;
    }

    // This is where we tell the config manager what services this module provides.
    public List&lt;ProvidedService&gt; GetProvidedServices()
    {
        // These are the default implementations of the services that Foundry Core provides.
        // Since they're defined as services, if someone wants to replace them with their own implementation they can.
        return new List&lt;ProvidedService&gt;
        {
            new ProvidedService
            {
                ImplementationName = &quot;Core Scene Navigator&quot;,
                ServiceInterface = typeof(ISceneNavigator)
            },
            new ProvidedService
            {
                ImplementationName = &quot;Core Player Rig Manager&quot;,
                ServiceInterface = typeof(IPlayerRigManager)
            },
            new ProvidedService
            {
                ImplementationName = &quot;Core Camera Manager&quot;,
                ServiceInterface = typeof(IFoundryCameraManager)
            }
        };
    }

    // Provide a list of services that this module uses.
    public List&lt;UsedService&gt; GetUsedService()
    {
        // These are the services that Foundry Core requires to function.
        // The reason that we still report these as used even if we provide them is so that if someone wants to 
        // replace them with their own implementation they can. Also if a service is not marked as required by at 
        // least one module a provider won't be automatically chosen and a lot of bugs might happen.
        // These also show up in the config manager so that users can see what services are required by each module.
        return new List&lt;UsedService&gt;
        {
            new UsedService
            {
                optional = false,
                ServiceInterface = typeof(ISceneNavigator)
            },
            new UsedService
            {
                optional = false,
                ServiceInterface = typeof(IPlayerRigManager)
            },
            new UsedService
            {
                optional = false,
                ServiceInterface = typeof(IFoundryCameraManager)
            },
            new UsedService
            {
                optional = false,
                ServiceInterface = typeof(INetworkProvider)
            }
        };
    }

    // This should always return a reference to the module config asset, or create one if it doesn't exist.
    // The preferred path for this is Assets/Foundry/Settings/YourConfig.asset
    public FoundryModuleConfig GetModuleConfig()
    {
        // This is that same helper function from the module config, you can see how it makes this whole workflow a lot easier.
        return FoundryCoreConfig.GetAsset();
    }
}
</code></pre>
<h2 id="service-definitions-and-implementations">Service Definitions and Implementations</h2>
<p>Now that we know how to define a module, let's look at how to define a service.</p>
<p>A service is just a regular C# interface that defines a set of functionality. Lets take a the IPlayerRigManager service as an example. The way that the player rig works in foundry is that it's created once on startup, and then &quot;borrowed&quot; by interaction rigs like NetworkPlayer or MenuPlayer as an input source (this is how we handle things like async loading and whatnot)</p>
<p>The <code>IPlayerRigManager</code> interface defines all the needed methods and events, and then <code>PlayerRigManagerService</code> Is the class that actually defines the functionality. (If you look above in the module config you can see that we provide a callback that returns a new instance of <code>PlayerRigManagerService</code>)</p>
<pre><code class="lang-cs">public delegate void PlayerRigEvent(IPlayerControlRig rig);

/// &lt;summary&gt;
/// Service to manage the lifecycle of the player rig.
/// &lt;/summary&gt;
public interface IPlayerRigManager
{
    /// &lt;summary&gt;
    /// Grab the current instantiated player rig.
    /// &lt;/summary&gt;
    public IPlayerControlRig Rig { get; }

    /// &lt;summary&gt;
    /// Register player rig after it's been created, along with the place to put it when it's not in use (Usually while loading)
    /// &lt;/summary&gt;
    public void RegisterRig(IPlayerControlRig rig, Transform unusedRigHolder);

    /// &lt;summary&gt;
    /// Register the rig as in use
    /// &lt;/summary&gt;
    public IPlayerControlRig BorrowPlayerRig();

    /// &lt;summary&gt;
    /// Register the rig as no longer in use
    /// &lt;/summary&gt;
    public void ReturnPlayerRig();

    /// &lt;summary&gt;
    /// Event that fires when the player rig is first created.
    /// &lt;/summary&gt;
    public event PlayerRigEvent PlayerRigCreated;

    public event PlayerRigEvent PlayerRigBorrowed;
    public event PlayerRigEvent PlayerRigReturned;
}
</code></pre>
<p>The last thing we need to do is tell foundry that this service exists. We do this by creating another editor-only class that implements <code>Foundry.Core.Editor.IServiceDefinition</code>. The classes that inherit from this interface are how we tell foundry what interfaces your package provides, what type they are, what name to display for them, and what package they come from.</p>
<pre><code class="lang-cs">public class PlayerRigManagerDefinition : IServiceDefinition
{

    public string Source()
    {
        return &quot;com.cyberhub.foundry.core&quot;;
    }

    public string PrettyName()
    {
        return &quot;Player Rig Manager&quot;;
    }

    public Type ServiceInterface()
    {
        return typeof(IPlayerRigManager);
    }
}
</code></pre>
<p>All you would need to do for Foundry to use a new system for managing player rigs is:</p>
<ol>
<li>Create a new implementation of <code>IPlayerRigManager</code></li>
<li>Add it to the list of provided services in your module definition</li>
<li>add a constructor to your module config that returns a new instance of your implementation.</li>
</ol>
<p>Now you're all set! Let's see what modules you build!</p>

</article>


        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Foundry Core Docs
        </div>
      </div>
    </footer>
  </body>
</html>
